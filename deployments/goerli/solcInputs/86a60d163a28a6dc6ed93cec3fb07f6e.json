{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "contracts/BankingTranscation.sol": {
      "content": "// SPDX-License-Identifier: MIT LICENSED\npragma solidity ^0.8.8;\n\n/* This contract is about sending your ETH to the BANK(contract) and retieve when you need or \n   you can send to someone\n   function:\n   payment\n   withdraw\n   send_to\n   View_deposited amount\n*/\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\ncontract BankingAmount{\n    // using PriceConverter for uint256;\n    address public contractOwner;\n    struct Custmers{\n        address CustmerAddress;\n        uint256 amount;\n    }\n    AggregatorV3Interface public PriceFeed;\n    constructor(address PriceFeedAddress){\n       contractOwner= msg.sender;\n       PriceFeed=AggregatorV3Interface(PriceFeedAddress);\n    }\n    Custmers[] public people;\n    mapping(address => uint256) public Balance;\n\n    function payment() public payable{\n        people.push(Custmers(msg.sender,msg.value));\n        Balance[msg.sender]= Balance[msg.sender]+ msg.value;\n    }\n    function ViewAmount(address USER_ADDRESS) public view returns(uint256){\n        return Balance[USER_ADDRESS];\n    }\n    function send_to(address payable to_receiever) public payable{\n        address from_user=msg.sender;\n        (bool sent,) = to_receiever.call{value: Balance[from_user]}(\"\");\n        require(sent, \"Failed to send Ether\");\n        Balance[to_receiever]=Balance[to_receiever]+Balance[from_user];\n        Balance[from_user]=0;\n    }\n    function withDraw() public payable{\n        address withdraw=msg.sender;\n        (bool sent,)=withdraw.call{value:Balance[withdraw]}(\"\");\n        require(sent, \"Failed to withdraw Ether\");\n        Balance[withdraw]=0;\n    }\n    \n}"
    },
    "contracts/PriceConverter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nlibrary PriceConverter {\n  function getPrice(AggregatorV3Interface priceFeed)\n    internal\n    view\n    returns (uint256)\n  {\n    (, int256 answer, , , ) = priceFeed.latestRoundData();\n    // ETH/USD rate in 18 digit\n    return uint256(answer * 10000000000);\n  }\n\n  // 1000000000\n  // call it get fiatConversionRate, since it assumes something about decimals\n  // It wouldn't work for every aggregator\n  function getConversionRate(uint256 ethAmount, AggregatorV3Interface priceFeed)\n    internal\n    view\n    returns (uint256)\n  {\n    uint256 ethPrice = getPrice(priceFeed);\n    uint256 ethAmountInUsd = (ethPrice * ethAmount) / 1000000000000000000;\n    // the actual ETH/USD conversation rate, after adjusting the extra 0s.\n    return ethAmountInUsd;\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}